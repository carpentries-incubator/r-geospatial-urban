---
title: "Lesson 4: OSM Data & GIS operation"
author: "Clémentine Cottineau"
format: 
  revealjs:
    footer: "Geospatial Data Carpentry for Urbanism"
    chalkboard: true
    incremental: true   
editor: 
  markdown: 
    wrap: 72
---

## Recorded session for teacher training

![](fig/UTQ.png){width="65%"} ![](fig/zoomGDCU_UTQ.png){width="25%"}

## Recap of the previous lessons:

By this point, you should be able to...

-   organise the workspace in `RStudio`

-   use the basic functions of `R`

-   import, analyse, visualise and save vector data with the `sf`
    package

-   import, analyse, visualise and save raster data with the `terra`
    package

# Part 1. Import vector data from Open Street Map

## Learning objectives

By the end of this lesson, you should be able to...

-   Import OpenStreetMap vector data using the `Nominatim` API

-   Visualise OSM vector data in `R`

-   Use the `Leaflet` package to create interactive maps

```{r}
#| label: setup
#| include: false
# install.packages("devtools")
# devtools::install_github("hadley/emo")


library(dplyr)
library(sf)
library(ggplot2)
library(osmdata)
library(leaflet)
library(emo)


knitr::opts_chunk$set(
  cache = FALSE,
  echo = TRUE,
  message = FALSE, 
  warning = FALSE
  )
```

## What is OpenStreetMap? `r emo::ji("map")`

::: columns
::: {.column width="60%"}
![](fig/OSM1.png){fig-align="center"}
:::

::: {.column width="40%"}
-   Collaborative project

-   Mapping the world

-   Sharing geospatial data
:::
:::

## What is OpenStreetMap? `r emo::ji("map")`

Anyone can contribute, by:

-   **adding information** on existing map objects

-   **mapping objects** (buildings, roads) from satellite imagery (cf.
    [HOT: Humanitarian OpenStreetMap Team](https://www.hotosm.org/)).

-   checking and validating data. This ensures that the information is
    **accessible**, **open**, **accurate** and **up-to-date**.

## OSM `r emo::ji("map")`

The OSM information system relies on :

-   geometrical **objects** (i.e. points, lines, polygons)

-   associated **tags** organised hierarchically

-   Ex: #building #height #road #secondary #90kph

## How to extract geospatial data from Open Street Map with R?

Define the **area** in which to retrieve data = *bounding box*.

This can be done using a place name and the `Nominatim` API (through the
R package `nominatimlite`)

We are going to look at *Brielle* together.

You can also try with *Naarden*, *Geertruidenberg*, *Gorinchem*,
*Enkhuizen* or *Dokkum* if you prefer.

## The Bounding Box `r emo::ji("square")`

We first geocode our spatial text search and extract the corresponding
polygon (`geo_lite_sf`) and then extract its bounding box (`st_bbox`).

```{r osm-bounding-box}
nominatim_polygon <- nominatimlite::geo_lite_sf(address = "Brielle", points_only = FALSE)
bb <- sf::st_bbox(nominatim_polygon)
bb
```

## The Bounding Box `r emo::ji("square")`

A Problem with download? Try:

```{r proxy}
assign("has_internet_via_proxy", TRUE, environment(curl::has_internet))

nominatim_polygon <- nominatimlite::geo_lite_sf(address = "Brielle", points_only = FALSE)
bb <- sf::st_bbox(nominatim_polygon)
bb
```

## Caution

There might be multiple responses from the API query, corresponding to
different objects at the same location, or different objects at
different locations.

For example: ![Brielle, Netherlands](fig/Brielle_NL.jpeg){width="30%"}
or ![Brielle, New Jersey](fig/Brielle_NJ.jpeg){width="30%"}

## Which Brielle?

By default, `nominatimlite::geo_lite_sf()` returns the first item.

Try to be as unambiguous as possible by adding a country code or
district name.

```{r osm-bounding-box2}
nominatim_polygon <- nominatimlite::geo_lite_sf(
  address = "Brielle, NL", 
  points_only = FALSE
  )

bb <- sf::st_bbox(nominatim_polygon)
bb
```

## Extracting features

A [feature](https://wiki.openstreetmap.org/wiki/Map_features) in the OSM
language is a category or tag of a geospatial object.

**Features** are described by general keys (e.g. "building", "boundary",
"landuse", "highway"), themselves decomposed into sub-categories
(values) such as "farm", "hotel" or "house" for `buildings`, "motorway",
"secondary" and "residential" for `highway`. This determines how they
are represented on the map.

## Searching the documentation

::: columns
::: {.column width="40%"}
Let's say we want to download data from OpenStreetMap and we know there
is a package for it named `osmdata`, but we don't know which function to
use and what arguments are needed. Where should we start?
:::

::: {.column width="60%"}
> Let's check the documentation
> [online](https://docs.ropensci.org/osmdata/):

![](fig/osmdata.png)
:::
:::

## Searching the documentation

There is a function to extract features `opq()`. It seems to work in
combination with `add_osm_feature()` and `osmdata_sf()`:

-   Click on the function names to know more.

-   Read about the arguments needed for each function: bounding box for
    `opq()` and some `key` and `value` for `add_osm_feature()`.

-   Look at the examples provided. How do they relate with your
    objective?

## Extracting OSM features

With these tips and examples, we can write our feature extraction
function as follows:

```{r osm-feature}

x <- opq(bbox = bb) %>%
   add_osm_feature(key = 'building')%>%
    osmdata_sf()

```

What is this x object made of?

## Extracting OSM features

```{r osm-feature-preview}

head(x$osm_polygons)

```

## Extracting OSM features

-   It is a **table** of all the buildings contained in the bounding
    box, which gives us their **OSM id**, their **geometry** and a range
    of **attributes**, such as their name, building material, building
    date, etc.
-   The **completion** level of this table depends on user contributions
    and open resources (here for instance: BAG, different in other
    countries).

## Mapping

Case Study: we are interested in mapping building age in Brielle. We
need to look into specific attributes:

-   the **age** of buildings
-   with a **subset** of buildings from after 1900
-   within the **Brielle** bounding box

## Projections

-   First, we are going to select the polygons and reproject them with
    the Amersfoort/RD New projection, suited for maps centred on the
    Netherlands.

-   This code for this projection is: 28992.

```{r reproject}
buildings <- x$osm_polygons %>%
  st_transform(.,crs=28992)
```

## Mapping urbanisation in Brielle

-   Then we create a variable which a threshold at 1900.

-   Every date prior to 1900 will be recoded 1900.

-   we use the `ggplot` function to visualise the buildings by age.

## Mapping urbanisation in Brielle

```{r map-age}
start_date <- as.numeric(buildings$start_date)
buildings$build_date <- if_else(start_date < 1900, 1900, start_date)

 ggplot(data = buildings) +
   geom_sf(aes(fill = build_date, colour=build_date))  +
   scale_fill_viridis_c(option = "viridis")+
   scale_colour_viridis_c(option = "viridis")

```

## Mapping urbanisation in Brielle

::: columns
::: {.column width="60%"}
![](fig/rmd-04map-age-1.png){fig-align="center"}
:::

::: {.column width="40%"}
So this reveals the historical centre of \[city\] and the various
extensions. Anything odd? what? around the centre? Why these limits /
isolated points?
:::
:::

## `r emo::ji("alarm")` Challenge

Import an interactive basemap layer under the buildings with `Leaflet`

```{r}
#| echo: false
#| cache: false
countdown::countdown(minutes = 20)
```

-   Check out the [leaflet package
    documentation](https://rstudio.github.io/leaflet/)

-   Plot a basemap in Leaflet and try different tiles. [Basemap
    documentation](https://rstudio.github.io/leaflet/basemaps.html)

-   Transform the buildings into WGS84 projection and add them to the
    basemap layer with the `addPolygons` function.

-   Have the `fillColor` of these polygons represent the `build_date`
    variable. See the [choropleth documentation](https://rstudio.github.io/leaflet/choropleths.html) for use of colors. Tip: use the examples given in the documentation and replace the variable names where needed.

![](fig/leafletBrielle.png){fig-align="center"}

## `r emo::ji("alarm")` To submit your work in Zoom:

![](fig/zoomGDCU_UTQ.png)

## `r emo::ji("alarm")` One solution

```{r}
buildings2 <- buildings %>%
  st_transform(.,crs=4326)

leaflet(buildings2) %>%
# addTiles()
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(color = "#444444", weight = 0.1, smoothFactor = 0.5,
  opacity = 0.2, fillOpacity = 0.8,
  fillColor = ~colorQuantile("YlGnBu", -build_date)(-build_date),
  highlightOptions = highlightOptions(color = "white", weight = 2,
    bringToFront = TRUE))
```

## Summary and keypoints

We have seen how OSM geodata works and how to import, select, and
visualise OSM vector data.

In short:

-   Use the `Nominatim` and `OverPass` APIs within R

-   Use the `osmdata` and `nominatimlite` packages to retrieve
    geospatial data

-   Select features and attributes among OSM tags

-   Use the `ggplot`, `sf` and `leaflet` packages to map data

## Before the break

-   Stop the zoom recording

-   Please fill out this feedback survey for Teacher Training purposes,
    at vevox.app (Code: `149-763-370`) or:

![](fig/qrcode_vevoxapp.png)

# Part 2. How to perform basic GIS operations with the `sf` package?

## Objectives:

By the end of this session, you should be able to:

-   Perform **unions**, **joins** and **intersection** operations

-   Compute the **area** of spatial polygons

-   Create **buffers and centroids**

-   **Map** the results

## the 'sf' package `r emo::ji("box")`

-   `sf`: ["a standardized way to encode spatial vector
    data."](https://cran.r-project.org/web/packages/sf/sf.pdf).

-   Contains traditional GIS functions: change the coordinate system,
    join layers, intersect or fuse polygons, create buffers and
    centroids, etc.

-   [cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/sf.pdf).

## the 'sf' cheatsheet `r emo::ji("map")`

![](fig/sf_cheatsheet1.png){fig-align="center"}

## the 'sf' cheatsheet `r emo::ji("map")`

![](fig/sf_cheatsheet2.png){fig-align="center"}

## Conservation in Brielle, NL `r emo::ji("building")`

Let's focus on old buildings and imagine we're in charge of their
conservation. We want to know how much of the city would be affected by
a non-construction zone of 100m around pre-1800 buildings.

Let's select them and see where they are.

## Conservation in Brielle, NL `r emo::ji("building")`

```{r old-buildings}
old <- 1800 # year prior to which you consider a building old


nominatim_polygon <- nominatimlite::geo_lite_sf(
  address = "Brielle, NL", points_only = FALSE)
bb <- sf::st_bbox(nominatim_polygon)
x <- opq(bbox = bb) %>%
   add_osm_feature(key = 'building') %>%
    osmdata_sf()
buildings <- x$osm_polygons %>%
  st_transform(.,crs=28992)


summary(buildings$start_date)

```

## Conservation in Brielle, NL `r emo::ji("building")`

```{r }
buildings$start_date <- as.numeric(as.character(buildings$start_date))

old_buildings <- buildings %>%
  filter(start_date <= old)

 ggplot(data = old_buildings) + geom_sf(colour="red")
 
```

## Basic GIS operations

As conservationists, we want to create a zone around historical
buildings where building regulation will have special restrictions to
preserve historical buildings.

## Buffer

Let's say this zone should be 100 meters. In GIS terms, we want to
create a buffer around polygons. The corresponding function `sf` is
`st_buffer`, with 2 arguments:

-   "x": the polygons around which to create buffers
-   "dist": the radius of the buffer.

## Buffer

```{r}

 distance <- 100 # in meters 
 
# First, we check that the "old_buildings" 
# layer projection is measured in meters:
st_crs(old_buildings)

```

## Buffer

```{r}
#then we use `st_buffer()`
buffer_old_buildings <- 
  st_buffer(x = old_buildings, dist = distance)
 
 ggplot(data = buffer_old_buildings) + geom_sf()
 
```

## Union

Now, we have overlapping buffers.

To fuse (or dissolve) them into a **unique** conservation zone/polygon,
we use `sf::st_union` with `st_cast()` to explicit the type of object
(*POLYGON* instead of the default *MULTIPOLYGON*), and `st_as_sf()` to
transform the polygon into an `sf` object.

```{r union}
single_old_buffer <- st_union(buffer_old_buildings) %>%
   st_cast(to = "POLYGON") %>%
  st_as_sf() 

single_old_buffer<- single_old_buffer %>%
  mutate("ID"=as.factor(1:nrow(single_old_buffer))) %>%
  st_transform(.,crs=28992) 
  
```

We create unique IDs to identify the new polygons.

## Centroids

For speed, we might want to represent buildings by a single point (for
instance: their geometric centre) rather than footprint.

This operation means defining their centroid and the corresponding
function is `st_centroid`.

## Centroids

```{r centroids}
sf::sf_use_s2(FALSE)
centroids_old <- st_centroid(old_buildings) %>%
  st_transform(.,crs=28992)  

ggplot() + 
    geom_sf(data = single_old_buffer, aes(fill=ID)) +
    geom_sf(data = centroids_old)
```

## Intersection

To distinguish conservation areas based on the number of historic
buildings they contain, we need to know how many **centroids** each
fused buffer polygon contains.

This means intersecting the layer of polygons with the layer of points.
`st_intersection` adds the attributes of the intersected polygon buffers
(e.g. ID) to the data table of the centroids.

## Intersection

To distinguish conservation areas based on the number of historic
buildings they contain, we need to know how many **centroids** each
fused buffer polygon contains.

This means intersecting the layer of polygons with the layer of points.
`st_intersection` adds the attributes of the intersected polygon buffers
(e.g. ID) to the data table of the centroids.

We then aggregate them by ID number (`group_by(ID)`) and sum the
variable `n` to know how many centroids are contained in each
polygon-buffer.

## Intersection

```{r }

 centroids_buffers <- 
  st_intersection(
    centroids_old,
    single_old_buffer
    ) %>%
   mutate(n=1)

centroid_by_buffer <- centroids_buffers %>%
   group_by(ID) %>%
   summarise(n = sum(n))
 
 single_buffer <- single_old_buffer %>%
   mutate(n_buildings = centroid_by_buffer$n)

 
  ggplot() + 
   geom_sf(data = single_buffer, aes(fill=n_buildings)) +
   scale_fill_viridis_c(alpha = 0.8,
                        begin = 0.6,
                        end = 1,
                        direction = -1,
                        option = "B")

```

## Final Output

Let's map this layer over the initial map of individual buildings.

```{r visu-1800}
ggplot() + 
   geom_sf(data = buildings) +
   geom_sf(data = single_buffer, aes(fill=n_buildings), colour = NA) +
   scale_fill_viridis_c(alpha = 0.6,
                        begin = 0.6,
                        end = 1,
                        direction = -1,
                        option = "B") 

```

## `r emo::ji("alarm")`Challenge: Conservation rules have changed!

The historical threshold now applies to all **pre-WWII** buildings, but
the distance to these building is reduced to **10m**.

Can you map the number of all buildings per 10m fused buffer?

```{r}
#| echo: false
#| cache: false
countdown::countdown(minutes = 10)
```

## One solution

```{r intersection_viz}

old <- 1939 
distance <- 10

# select
old_buildings <- buildings %>%
  filter(start_date <= old)

# buffer
buffer_old_buildings <- st_buffer(old_buildings, dist = distance)
  
# union
single_old_buffer <- st_union(buffer_old_buildings) %>%
  st_cast(to = "POLYGON") %>%
  st_as_sf()  
 
single_old_buffer <- single_old_buffer %>%
  mutate("ID"=1:nrow(single_old_buffer))  %>%
  st_transform(single_old_buffer,crs=4326) 

# centroids
centroids_old <- st_centroid(old_buildings) %>%
  st_transform(.,crs=4326)  
  
# intersection
centroids_buffers <- st_intersection(centroids_old,single_old_buffer) %>%
  mutate(n=1)
 
centroid_by_buffer <- centroids_buffers %>% 
  group_by(ID) %>%
  summarise(n = sum(n))
  
single_buffer <- single_old_buffer %>% 
  mutate(n_buildings = centroid_by_buffer$n)
  ggplot() + 
    geom_sf(data = buildings) +
    geom_sf(data = single_buffer, 
            aes(fill = n_buildings), colour = NA) +
    scale_fill_viridis_c(alpha = 0.6,
                         begin = 0.6,
                         end = 1,
                         direction = -1,
                         option = "B")    

```

## Problem

::: columns
::: {.column width="30%"}
*Problem: there are many pre-war buildings and the buffers are large so
the number of old buildings is not very meaningful. Let's compute the
density of old buildings per buffer zone.*
:::

::: {.column width="70%"}
![](fig/rmd-04prewar-replication-1.png){fig-align="center"}
:::
:::

## `r emo::ji("alarm")` Challenge: visualise the density of old buildings

```{r}
#| echo: false
#| cache: false
countdown::countdown(minutes = 10)
```

Let's compute the **density** of old buildings per buffer zone (= number
of buildings / area of buffer).

## Solution

Let's map this layer over the initial map of individual buildings.

```{r area}
single_buffer$area <- sf::st_area(single_buffer)  %>% 
  units::set_units(., km^2)

single_buffer$old_buildings_per_km2 <- as.numeric(
  single_buffer$n_buildings / single_buffer$area
  )

 ggplot() + 
   geom_sf(data = buildings) +
   geom_sf(data = single_buffer, 
           aes(fill=old_buildings_per_km2),
           colour = NA) +
   scale_fill_viridis_c(alpha = 0.6,
                        begin = 0.6,
                        end = 1,
                        direction = -1,
                        option = "B") 
 
 
```

## Summary and keypoints

We have seen how to create spatial buffers and centroids, how to
intersect vector data and how retrieve the area of polygons.

In short:

-   Use the `st_*` functions from `sf` for basic GIS operations

-   Perform unions, joins and intersection operations

-   Compute the area of spatial polygons with `st_area()`

## What's next?

-   Workshop material and links to other resources will be shared

-   [R Café](https://delft-rcafe.github.io/home/Index.html)

-   The [DCC](https://www.tudelft.nl/index.php?id=67120&L=1/) and the
    [TU Delft
    Library](https://www.tudelft.nl/en/library/research-data-management/r/training-events/training-for-researchers)
    are there to help

## `r emo::ji("talk")` A few words of caution

We have taught you to think, type, try, test, read the documentation.
This is not only the *old fashion way*, but the **foundation.**

When you encounter a bug, a challenge, a question that we have not
covered, you could always make use of:

-   StackOverflow
-   chatGPT
-   `< include name of future AI here >`

## `r emo::ji("talk")` A few words of caution

Be careful to keep it as a *help, tool and support* whose quality you
can still assess.

They can provide fixes that you do not understand, answers that don't
make sense, and even wrong answers! So build yourself some
**foundations** before you get into them.

## `r emo::ji("rabbit")`The end... wait!

![](fig/Thats_all_folks.svg.png){fig-align="center"}

Any questions?

## Feedback

::: columns
::: {.column width="70%"}
**D**: what we should **drop** because it's not useful

**A**: what we should **add** because it's missing

**K**: what we should **keep** because it's well done

**I**: what we should **improve** because it's not there yet
:::

::: {.column width="30%"}
![](fig/post-workshop-survey.png)
:::
:::

## Thank you

-   the **workshop team**: Aleks, Ana, Claudiu, Clémentine, Daniele,
    Javi, Jérôme, Kyri, Manuel, Paula, Selin + TU Library & BK Faculty

-   **you**: the active, team-playing and motivated participants

## Time for rewards

-   for PhD Candidates: some **GS Credits**!

-   for the competing teams...

## Rbanism


::: columns
::: {.column width="55%"}
A TUD **community** that promotes open-source software and
**open-science** practices in the field of **urbanism.**


![](fig/sticker2.png){width=40%}
:::

::: {.column width="45%"}

Join the community!

![](fig/rbanism-membership.png){width=70%,fig-align="center"}

:::
:::

## Call for helpers!

This workshop is offered on a yearly basis.

You are welcome to join the team for future events as *helpers* and/then
as *instructors*.

This strengthens the community... and it can bring you GS Credits.

## `r emo::ji("rabbit")`The end... for real!

![](fig/Thats_all_folks.svg.png){fig-align="center"}
